# 7주차 - DynamoDB

### 6주차 과제

📌 **Lambda + CloudFront** 개념 정리 + 실습 과정 캡쳐본 첨부

→ 개인페이지에 링크(깃허브, 노션, 블로그) 형식으로 과제 제출

---

📌 Todo-List

- [x]  **섹션 9. AWS - DynamoDB**
<br>

## 개념

### **섹션 9. AWS - DynamoDB**

[9-1] DynamoDB란?

- **NoSQL(Not Only SQL)** 데이터베이스
관계형 DB + 다른 형태의 DB
- 매우 빠른 쿼리 속도
- **Auto-Scaling** 기능 탑재
데이터베이스 생성 시 크기가 정해지는데, 데이터의 크기가 추가될 시 테이블의 크기가 알아서 늘어나고 줄어듦 →  비용 절감
- Key-Value 데이터 모델 지원
데이터를 쿼리할 때 키에 해당하는 value를 가져옴 ↔ 관계형 DB
- 테이블 생성 시 스키마 정의할 필요 없음
→ 실시간으로 들어오는 데이터 복원
→ 모바일, 웹, IoT 데이터 사용 시 추천
- SSD 스토리지 사용 → 읽고 쓰는 속도 ⬆️

### DynamoDB 구성

- 테이블 (Table)
- 아이템 (Items) - 행(row)과 개념이 비슷함
- 특징 (Attributes) - 열(column)과 개념이 비슷함
- **Key-Value** (Key : 데이터의 이름, Value : 데이터 자신)
ex. JSON, XML 등 Key-Value 형태

### 데이터를 쿼리하는 방법 - Primary Keys

- PK(모든 데이터들의 고유 키)를 사용하여 데이터 쿼리
- **파티션 키 (Partition Key)**
    - 데이터를 나누고 분리시킴
    - 고유 특징 (Unique Attribute)
    - 실제 데이터가 들어가는 위치를 결정해줌
    : 파티션 키 내부에 들어있는 해시함수를 실행한 결과값 반환 → 데이터가 들어갈 주소값
    - 파티션 키 사용 시 동일한 두 개의 데이터가 같은 위치에 저장될 수 없음
    → 파티션 키는 중복 불가능
- **복합 키 (Composite Key)**
    - 파티션 키(Partition Key) + 정렬키(Sort Key)
    - ex. 똑같은 고객이 다른 날짜에 다른 물건을 구매
    파티션 키 : 고객 아이디, 정렬키 : 날짜(Timestamp)
    - 같은 파티션 키의 데이터들은 같은 장소에 보관 후 정렬키에 의해 정렬됨

**DynamoDB 데이터 접근 관리**

- **AWS IAM**으로 관리할 수 있음
    - 테이블 생성과 접근 권한을 부여할 수 있음
    - 특정 테이블, 데이터만 접근 가능하게 해주는 특별한 IAM 역할 존재
<br>

[9-2] Index

- 특정 컬럼만을 사용하여 쿼리
- 테이블 전체가 아닌 기준점(pivot)을 사용해 쿼리가 이루어짐
    
    → 매우 큰 쿼리 성능 효과
    
- 두 가지의 Index 유형
    - Local Secondary Index
    - Global Secondary Index

### Local Secondary Index (LSI)

- 테이블 생성 시에만 정의해줄 수 있음
- 테이블 생성 후 변경, 삭제가 불가능
- 똑같은 파티션 키 + 다른 정렬키 사용
- 파티션 키와 정렬키 둘 다 사용하기 때문에 정렬키를 기반으로 쿼리 수행 시 효율적임

### Global Secondary Index (GSI)

- 테이블 생성 후에도 추가, 변경, 삭제 가능
- 다른 파티션 키, 정렬키 사용

*뷰: 인덱스를 정의하면 기존에 있던 테이블에서 전혀 다른 파티션 키와 정렬 키를 가지고 있는 뷰가 복제됨
<br>

[9-3] Query vs Scan

DynamoDB에 들어있는 데이터를 읽어오는 방법

### Query

- 테이블 생성 시 정의한 PK를 사용하여 데이터 검색
- 쿼리 사용 시 모든 데이터(컬럼) 반환
추가적으로 정렬 키 사용할 수 있음
- PK와 정렬 키에 맞는 데이터의 모든 컬럼을 전부 반환
    
    → **ProjectionExpression 파라미터**
    : 원하는 컬럼만 반환하도록 수정
    

### Scan

- 테이블의 모든 데이터를 불러옴 (PK 사용 X)
- 우선 모든 데이터를 가져온 후 필터를 따로 추가하여 원하는 데이터 반환
- ProjectionExpression 파라미터
- 순차적 방법, 병렬 스캔

### Query vs Scan

- Query가 Scan보다 훨씬 효율적임
- 따라서 Query 사용 추천
- 테이블의 크기가 상대적으로 작고 테이블의 PK에 대한 정의가 필요 없는 **룩업 테이블** 조회 시 사용

*룩업 테이블: 실시간으로 데이터가 계속 업데이트 되는 테이블과 달리,
단순히 참고용으로 데이터 딕셔너리를 정의하고 보관하는 용도
<br>

[9-6] DAX

### DynamoDB Accelerator

- 클러스터 In-memory 캐시
*In-memory: 데이터를 SSD, 디스크가 아니라 캐시에 보관
→ 필요한 데이터를 찾을 때 속도 ⬆️
- 10배 이상의 속도 향상
- 읽기 요청만 해당사항 (X 쓰기요청)

**원리**

- DAX 캐싱 시스템
→ 테이블에 데이터 삽입 & 업데이트 시 DAX에도 반영
- 읽기 요청에 맞는 데이터가 DAX에 들어있을 시 DAX에서 데이터 즉시 반환
(Cache Hit) ↔ (Cache Miss)

**단점**

- 쓰기 요청이 많은 어플리케이션에서는 부적절함
- 읽기 요청이 많지 않은 어플리케이션에서 부적절함
- 캐시미스가 발생하면 비용 ⬆️
- 아직 모든 지역에서 제공하지 않음
<br>

[9-7] DynamoDB Streams

- 이벤트(DynamoDB 테이블에 삽입, 수정, 삭제 등) 발생 시 시간적 순서에 맞게 Streams에 기록
- **Log(로그)**: 이벤트가 스트림에 작성되는 것
로그는 즉각 암호화가 일어나며 24시간 동안 보관됨
- 주로 이벤트를 기록하고 이벤트 발생을 외부로 알리는 용도
ex. Lambda Function
- 이벤트 전&후에 대한 상황 보관